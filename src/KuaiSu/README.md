# 快速排序算法

## 原理

    通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小
    则可分别对这两部分记录继续进行排序，以达到整个序列有序。
    快速排序属于分治法的一种，就是说通过把数据分成几部分来同时处理的一种算法。
    快速排序是冒泡排序算法的一种改进，是一种不稳定的算法。
    
  
  
总结：是一个 __先从后向前找，再从前向后找。不断的挖坑、填坑__  的过程


1. i =L; j = R; 将基准数挖出形成第一个坑a[i]。
2. j--由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。
3. i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。
4. 再重复执行2，3二步，直到i==j，将基准数填入a[i]中。

```
5 8 1 6 2 3 9 7 4 
4 3 1 2 5 6 9 7 8 
2 3 1 4 5 6 9 7 8 
1 2 3 4 5 6 9 7 8 
1 2 3 4 5 6 9 7 8 
1 2 3 4 5 6 9 7 8 
1 2 3 4 5 6 9 7 8 
1 2 3 4 5 6 9 7 8 
1 2 3 4 5 6 9 7 8 
1 2 3 4 5 6 8 7 9 
1 2 3 4 5 6 7 8 9 
1 2 3 4 5 6 7 8 9 
1 2 3 4 5 6 7 8 9 
```

![](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif)

## 时间复杂度

快速排序是不稳定的排序算法，最坏是O(n2)，最好是O(n*logn)
```
快速排序的平均时间复杂度为 O(n log n)，其中 n 是待排序数组的长度。快速排序是一种基于分治法的排序算法，它通过选择一个基准元素，将数组划分为两个子数组，其中一个子数组中的元素都小于基准元素，另一个子数组中的元素都大于基准元素。然后对这两个子数组分别进行快速排序，递归地进行下去，直到子数组的长度为 1 或 0。

在平均情况下，快速排序的时间复杂度为 O(n log n)。这是因为每次划分都将数组划分为两个大小大致相等的子数组，所以每次划分的时间复杂度为 O(n)。而数组的划分过程需要进行 log n 次，因为每次划分都将数组的规模减半。因此，总的时间复杂度为 O(n log n)。

然而，在最坏情况下，快速排序的时间复杂度为 O(n^2)。最坏情况发生在每次划分都选择了当前子数组中的最大或最小元素作为基准元素时。这种情况下，每次划分只能将数组的规模减少 1，需要进行 n 次划分，因此总的时间复杂度为 O(n^2)。

为了避免最坏情况的发生，可以采用一些优化措施，如随机选择基准元素、三数取中法选择基准元素等，以提高快速排序的性能。
```

## 参考博文
- https://blog.csdn.net/morewindows/article/details/6684558
